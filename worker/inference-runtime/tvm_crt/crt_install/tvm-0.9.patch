diff --git a/Makefile b/Makefile
index a9987b8..c996e0e 100644
--- a/Makefile
+++ b/Makefile
@@ -45,8 +45,8 @@ QUIET ?= @
 CRT_PREFIX = $(wildcard src/crt)
 
 INCLUDES ?= -isystem include -iquote $(dir ${CRT_CONFIG})
-CFLAGS += ${INCLUDES} -Werror -g $(EXTRA_CFLAGS) -DDMLC_USE_LOGGING_LIBRARY=\<tvm/runtime/logging.h\>
-CXXFLAGS += ${INCLUDES} -std=c++11 -Werror -g $(EXTRA_CXXFLAGS) -DDMLC_USE_LOGGING_LIBRARY=\<tvm/runtime/logging.h\>
+CFLAGS += ${INCLUDES} -g $(EXTRA_CFLAGS) -DDMLC_USE_LOGGING_LIBRARY=\<tvm/runtime/logging.h\>
+CXXFLAGS += ${INCLUDES} -std=c++11 -g $(EXTRA_CXXFLAGS) -DDMLC_USE_LOGGING_LIBRARY=\<tvm/runtime/logging.h\>
 LDFLAGS += -Werror -g $(EXTRA_LDFLAGS)
 
 ${BUILD_DIR}/%.o: src/%.c $(CRT_CONFIG)
diff --git a/src/runtime/crt/common/crt_runtime_api.c b/src/runtime/crt/common/crt_runtime_api.c
index 23ab5af..666b135 100644
--- a/src/runtime/crt/common/crt_runtime_api.c
+++ b/src/runtime/crt/common/crt_runtime_api.c
@@ -592,19 +592,19 @@ tvm_crt_error_t RunTimeEvaluator(tvm_function_index_t function_index, TVMValue*
     double mean_exec_seconds = curr_res_seconds / g_time_evaluator_state.number;
     *iter = mean_exec_seconds;
     iter++;
-    if (g_time_evaluator_state.cooldown_interval_ms > 0 &&
-        (i % g_time_evaluator_state.repeats_to_cooldown) == 0) {
-#if defined(_WIN32) || defined(WIN32)
-      Sleep(g_time_evaluator_state.cooldown_interval_ms);
-#elif __unix__
-      usleep(g_time_evaluator_state.cooldown_interval_ms * 1000);
-#else
-      TVMAPIErrorf(
-          "No support for non-zero cooldown_interval_ms for this platform: Use "
-          "cooldown_interval_ms = 0");
-      goto release_and_return;
-#endif
-    }
+//     if (g_time_evaluator_state.cooldown_interval_ms > 0 &&
+//         (i % g_time_evaluator_state.repeats_to_cooldown) == 0) {
+// #if defined(_WIN32) || defined(WIN32)
+//       Sleep(g_time_evaluator_state.cooldown_interval_ms);
+// #elif __unix__
+//       usleep(g_time_evaluator_state.cooldown_interval_ms * 1000);
+// #else
+//       TVMAPIErrorf(
+//           "No support for non-zero cooldown_interval_ms for this platform: Use "
+//           "cooldown_interval_ms = 0");
+//       goto release_and_return;
+// #endif
+//     }
   }
 
   *ret_type_code = kTVMBytes;
diff --git a/src/runtime/crt/common/ndarray.c b/src/runtime/crt/common/ndarray.c
index b0e8697..4520aa5 100644
--- a/src/runtime/crt/common/ndarray.c
+++ b/src/runtime/crt/common/ndarray.c
@@ -75,7 +75,7 @@ int TVMNDArray_Load(TVMNDArray* ret, const char** strm) {
   memcpy(&header, *strm, sizeof(header));
   *strm += sizeof(header);
   if (header != kTVMNDArrayMagic) {
-    fprintf(stderr, "Invalid DLTensor file format\n");
+    // fprintf(stderr, "Invalid DLTensor file format\n");
     status = -1;
   }
   memcpy(&reserved, *strm, sizeof(reserved));
@@ -90,11 +90,11 @@ int TVMNDArray_Load(TVMNDArray* ret, const char** strm) {
   memcpy(&dtype, *strm, sizeof(dtype));
   *strm += sizeof(dtype);
   if ((ndim < 0) || (ndim > TVM_CRT_MAX_NDIM)) {
-    fprintf(stderr, "Invalid ndim=%d: expected to be 0 ~ %d.\n", ndim, TVM_CRT_MAX_NDIM);
+    // fprintf(stderr, "Invalid ndim=%d: expected to be 0 ~ %d.\n", ndim, TVM_CRT_MAX_NDIM);
     status = -1;
   }
   if (dev.device_type != kDLCPU) {
-    fprintf(stderr, "Invalid DLTensor device: can only save as CPU tensor\n");
+    // fprintf(stderr, "Invalid DLTensor device: can only save as CPU tensor\n");
     status = -1;
   }
   int64_t shape[TVM_CRT_MAX_NDIM] = {0};
@@ -118,10 +118,10 @@ int TVMNDArray_Load(TVMNDArray* ret, const char** strm) {
   memcpy(&data_byte_size, *strm, sizeof(data_byte_size));
   *strm += sizeof(data_byte_size);
   if (!(data_byte_size == num_elems * elem_bytes)) {
-    fprintf(stderr,
-            "invalid DLTensor file format: data_byte_size=%d, "
-            "while num_elems*elem_bytes=%d\n",
-            (int)data_byte_size, (int)(num_elems * elem_bytes));  // NOLINT(*)
+    // fprintf(stderr,
+    //         "invalid DLTensor file format: data_byte_size=%d, "
+    //         "while num_elems*elem_bytes=%d\n",
+    //         (int)data_byte_size, (int)(num_elems * elem_bytes));  // NOLINT(*)
     status = -1;
   }
   memcpy(ret->dl_tensor.data, *strm, data_byte_size);
diff --git a/src/runtime/crt/common/packed_func.c b/src/runtime/crt/common/packed_func.c
index 645b22f..b9d3760 100644
--- a/src/runtime/crt/common/packed_func.c
+++ b/src/runtime/crt/common/packed_func.c
@@ -63,7 +63,7 @@ DLDataType String2DLDataType(const char* s) {
     return t;
   } else {
     scan = s;
-    fprintf(stderr, "unknown type %s\n", s);
+    // fprintf(stderr, "unknown type %s\n", s);
   }
   char* xdelim;
   uint8_t bits = (uint8_t)(strtoul(scan, &xdelim, 10));
@@ -73,7 +73,7 @@ DLDataType String2DLDataType(const char* s) {
     t.lanes = (uint16_t)(strtoul(xdelim + 1, &endpt, 10));
   }
   if (!(endpt == s + strlen(s))) {
-    fprintf(stderr, "unknown type %s\n", s);
+    // fprintf(stderr, "unknown type %s\n", s);
   }
   return t;
 }
diff --git a/src/runtime/crt/graph_executor/graph_executor.c b/src/runtime/crt/graph_executor/graph_executor.c
index 395a343..49f9840 100644
--- a/src/runtime/crt/graph_executor/graph_executor.c
+++ b/src/runtime/crt/graph_executor/graph_executor.c
@@ -53,19 +53,19 @@ int NodeEntry_Load(TVMGraphExecutorNodeEntry* entry, JSONReader* reader) {
   int status = 0;
   reader->BeginArray(reader);
   if (!(reader->NextArrayItem(reader))) {
-    fprintf(stderr, "invalid json format: failed to parse `node_id`\n");
+    // fprintf(stderr, "invalid json format: failed to parse `node_id`\n");
     status = -1;
   }
   reader->ReadUnsignedInteger(reader, &(entry->node_id));
   if (!(reader->NextArrayItem(reader))) {
-    fprintf(stderr, "invalid json format: failed to parse `index`\n");
+    // fprintf(stderr, "invalid json format: failed to parse `index`\n");
     status = -1;
   }
   reader->ReadUnsignedInteger(reader, &(entry->index));
   if (reader->NextArrayItem(reader)) {
     reader->ReadUnsignedInteger(reader, &(entry->version));
     if (reader->NextArrayItem(reader)) {
-      fprintf(stderr, "invalid json format: failed to parse `version`\n");
+      // fprintf(stderr, "invalid json format: failed to parse `version`\n");
       status = -1;
     }
   } else {
@@ -85,7 +85,7 @@ void TVMGraphExecutorNode_LoadAttrs(TVMGraphExecutorNode* node, JSONReader* read
   while (reader->NextObjectItem(reader, key, sizeof(key))) {
     int status = reader->ReadString(reader, value, sizeof(value));
     if (status != 0) {
-      fprintf(stderr, "error reading value for key: %s\n", key);
+      // fprintf(stderr, "error reading value for key: %s\n", key);
       break;
     }
     if (!strcmp(key, "func_name")) {
@@ -107,7 +107,7 @@ void TVMGraphExecutorNode_LoadAttrs(TVMGraphExecutorNode* node, JSONReader* read
     }
   }
   if (bitmask != (1 | 2 | 4 | 8)) {
-    fprintf(stderr, "invalid format\n");
+    // fprintf(stderr, "invalid format\n");
   }
 }
 
@@ -120,14 +120,14 @@ int TVMGraphExecutorNode_Load(TVMGraphExecutorNode* node, JSONReader* reader) {
     if (!strcmp(key, "op")) {
       status = reader->ReadString(reader, node->op_type, sizeof(node->op_type));
       if (status != 0) {
-        fprintf(stderr, "error reading op\n");
+        // fprintf(stderr, "error reading op\n");
         break;
       }
       bitmask |= 1;
     } else if (!strcmp(key, "name")) {
       status = reader->ReadString(reader, node->name, sizeof(node->name));
       if (status != 0) {
-        fprintf(stderr, "error reading name\n");
+        // fprintf(stderr, "error reading name\n");
         break;
       }
       bitmask |= 2;
@@ -136,32 +136,32 @@ int TVMGraphExecutorNode_Load(TVMGraphExecutorNode* node, JSONReader* reader) {
       reader->BeginArray(reader);
       size_t num_inputs = 0;
       if (reader->ArrayLength(reader, &num_inputs) != 0) {
-        fprintf(stderr, "error determining inputs array length\n");
+        // fprintf(stderr, "error determining inputs array length\n");
         break;
       }
       DLDevice dev = {kDLCPU, 0};
       tvm_crt_error_t err = TVMPlatformMemoryAllocate(
           sizeof(TVMGraphExecutorNodeEntry) * num_inputs, dev, (void**)&node->inputs);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         return -1;
       }
       while (reader->NextArrayItem(reader)) {
         if (count == num_inputs) {
-          fprintf(stderr, "too many array elements\n");
+          // fprintf(stderr, "too many array elements\n");
           return -1;
         }
 
         TVMGraphExecutorNodeEntry* inputs = node->inputs + count;
         reader->BeginArray(reader);
         if (!reader->NextArrayItem(reader)) {
-          fprintf(stderr, "invalid json format\n");
+          // fprintf(stderr, "invalid json format\n");
           status = -1;
           break;
         }
         reader->ReadUnsignedInteger(reader, &(inputs->node_id));
         if (!reader->NextArrayItem(reader)) {
-          fprintf(stderr, "invalid json format\n");
+          // fprintf(stderr, "invalid json format\n");
           status = -1;
           break;
         }
@@ -169,7 +169,7 @@ int TVMGraphExecutorNode_Load(TVMGraphExecutorNode* node, JSONReader* reader) {
         if (reader->NextArrayItem(reader)) {
           reader->ReadUnsignedInteger(reader, &(inputs->version));
           if (reader->NextArrayItem(reader)) {
-            fprintf(stderr, "invalid json format\n");
+            // fprintf(stderr, "invalid json format\n");
             status = -1;
             break;
           }
@@ -186,10 +186,10 @@ int TVMGraphExecutorNode_Load(TVMGraphExecutorNode* node, JSONReader* reader) {
       TVMGraphExecutorNode_LoadAttrs(node, reader, &param);
       memcpy(&node->param, &param, sizeof(param));
     } else if (!strcmp(key, "control_deps")) {
-      fprintf(stderr, "do not support key %s", key);
+      // fprintf(stderr, "do not support key %s", key);
       status = -1;
     } else {
-      fprintf(stderr, "do not support key %s", key);
+      // fprintf(stderr, "do not support key %s", key);
       status = -1;
     }
     if (status != 0) {
@@ -197,7 +197,7 @@ int TVMGraphExecutorNode_Load(TVMGraphExecutorNode* node, JSONReader* reader) {
     }
   }
   if (bitmask != (1 | 2 | 4)) {
-    fprintf(stderr, "invalid format\n");
+    // fprintf(stderr, "invalid format\n");
     status = -1;
   }
   return status;
@@ -240,29 +240,29 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
     if (!strcmp(key, "dltype")) {
       reader->BeginArray(reader);
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       status = reader->ReadString(reader, type, sizeof(type));
       if (status != 0) {
-        fprintf(stderr, "error reading dltype type\n");
+        // fprintf(stderr, "error reading dltype type\n");
         break;
       }
       if (strcmp(type, "list_str")) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_str length\n");
+        // fprintf(stderr, "error determing list_str length\n");
         status = -1;
         break;
       }
@@ -270,20 +270,20 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
       tvm_crt_error_t err = TVMPlatformMemoryAllocate(TVM_CRT_MAX_STRLEN_DLTYPE * num_items, dev,
                                                       (void**)&attr->dltype);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         return -1;
       }
       dltype_count = 0;
       while (reader->NextArrayItem(reader)) {
         if (dltype_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
         status = reader->ReadString(reader, attr->dltype + dltype_count * TVM_CRT_MAX_STRLEN_DLTYPE,
                                     TVM_CRT_MAX_STRLEN_DLTYPE);
         if (status != 0) {
-          fprintf(stderr, "error reading dltype array item");
+          // fprintf(stderr, "error reading dltype array item");
           break;
         }
         dltype_count++;
@@ -291,7 +291,7 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
       attr->dltype_count = dltype_count;
 
       if (reader->NextArrayItem(reader)) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
@@ -299,28 +299,28 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
     } else if (!strcmp(key, "storage_id")) {
       reader->BeginArray(reader);
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       status = reader->ReadString(reader, type, sizeof(type));
       if (status != 0) {
-        fprintf(stderr, "error reading device_index array item");
+        // fprintf(stderr, "error reading device_index array item");
       }
       if (strcmp(type, "list_int")) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_str length\n");
+        // fprintf(stderr, "error determing list_str length\n");
         status = -1;
         break;
       }
@@ -328,13 +328,13 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
       tvm_crt_error_t err =
           TVMPlatformMemoryAllocate(sizeof(uint32_t) * num_items, dev, (void**)&attr->storage_id);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         return -1;
       }
       storage_id_count = 0;
       while (reader->NextArrayItem(reader)) {
         if (storage_id_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
@@ -342,7 +342,7 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
         storage_id_count++;
       }
       if (reader->NextArrayItem(reader)) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
@@ -350,29 +350,29 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
     } else if (!strcmp(key, "shape")) {
       reader->BeginArray(reader);
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       status = reader->ReadString(reader, type, sizeof(type));
       if (status != 0) {
-        fprintf(stderr, "error reading shape array item\n");
+        // fprintf(stderr, "error reading shape array item\n");
         break;
       }
       if (strcmp(type, "list_shape")) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_str length\n");
+        // fprintf(stderr, "error determing list_str length\n");
         status = -1;
         break;
       }
@@ -380,20 +380,20 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
       tvm_crt_error_t err = TVMPlatformMemoryAllocate(
           sizeof(int64_t) * TVM_CRT_MAX_NDIM * num_items, dev, (void**)&attr->shape);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       err = TVMPlatformMemoryAllocate(sizeof(uint32_t) * num_items, dev, (void**)&attr->ndim);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       shape_count = 0;
       while (reader->NextArrayItem(reader)) {
         if (shape_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
@@ -418,7 +418,7 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
       }
       attr->shape_count = shape_count;
       if (reader->NextArrayItem(reader)) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
@@ -426,29 +426,29 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
     } else if (!strcmp(key, "device_index")) {
       reader->BeginArray(reader);
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       status = reader->ReadString(reader, type, sizeof(type));
       if (status != 0) {
-        fprintf(stderr, "error reading device_index array item");
+        // fprintf(stderr, "error reading device_index array item");
         break;
       }
       if (strcmp(type, "list_int")) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_int length\n");
+        // fprintf(stderr, "error determing list_int length\n");
         status = -1;
         break;
       }
@@ -456,14 +456,14 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
       tvm_crt_error_t err =
           TVMPlatformMemoryAllocate(sizeof(uint32_t) * num_items, dev, (void**)&attr->device_index);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       device_index_count = 0;
       while (reader->NextArrayItem(reader)) {
         if (device_index_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
@@ -471,21 +471,21 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
         device_index_count++;
       }
       if (reader->NextArrayItem(reader)) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
     } else {
       reader->BeginArray(reader);
       if (!(reader->NextArrayItem(reader))) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
       reader->ReadString(reader, type, sizeof(type));
       if (!strcmp(type, "list_int")) {
         if (!(reader->NextArrayItem(reader))) {
-          fprintf(stderr, "Invalid json format\n");
+          // fprintf(stderr, "Invalid json format\n");
           status = -1;
           break;
         }
@@ -498,26 +498,26 @@ int TVMGraphExecutorGraphAttr_Load(TVMGraphExecutorGraphAttr* attr, JSONReader*
         }
       } else if (!strcmp(type, "size_t")) {
         if (!(reader->NextArrayItem(reader))) {
-          fprintf(stderr, "Invalid json format\n");
+          // fprintf(stderr, "Invalid json format\n");
           status = -1;
           break;
         }
         uint32_t temp;
         reader->ReadUnsignedInteger(reader, &temp);
       } else {
-        fprintf(stderr, "cannot skip graph attr %s", key);
+        // fprintf(stderr, "cannot skip graph attr %s", key);
         status = -1;
         break;
       }
       if (reader->NextArrayItem(reader)) {
-        fprintf(stderr, "Invalid json format\n");
+        // fprintf(stderr, "Invalid json format\n");
         status = -1;
         break;
       }
     }
   }
   if (bitmask != (1 | 2 | 4)) {
-    fprintf(stderr, "invalid format\n");
+    // fprintf(stderr, "invalid format\n");
     status = -1;
   }
   return status;
@@ -581,7 +581,7 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_int length\n");
+        // fprintf(stderr, "error determing list_int length\n");
         status = -1;
         break;
       }
@@ -589,20 +589,20 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       tvm_crt_error_t err = TVMPlatformMemoryAllocate(sizeof(TVMGraphExecutorNode) * num_items, dev,
                                                       (void**)&executor->nodes);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       while (reader->NextArrayItem(reader)) {
         if (executor->nodes_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
         TVMGraphExecutorNode* node = executor->nodes + executor->nodes_count;
         status = TVMGraphExecutorNode_Load(node, reader);
         if (status != 0) {
-          fprintf(stderr, "failed to load an element in `nodes` field in graph executor node.\n");
+          // fprintf(stderr, "failed to load an element in `nodes` field in graph executor node.\n");
           break;
 #if TVM_CRT_DEBUG
         } else {
@@ -616,7 +616,7 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_int length\n");
+        // fprintf(stderr, "error determing list_int length\n");
         status = -1;
         break;
       }
@@ -625,13 +625,13 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
                                                       (void**)&executor->input_nodes);
 
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       while (reader->NextArrayItem(reader)) {
         if (executor->input_nodes_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
@@ -644,7 +644,7 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_int length\n");
+        // fprintf(stderr, "error determing list_int length\n");
         status = -1;
         break;
       }
@@ -652,13 +652,13 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       tvm_crt_error_t err = TVMPlatformMemoryAllocate(sizeof(uint32_t) * num_items, dev,
                                                       (void**)&executor->node_row_ptr);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       while (reader->NextArrayItem(reader)) {
         if (executor->node_row_ptr_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
@@ -672,7 +672,7 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       reader->BeginArray(reader);
       size_t num_items = 0;
       if (reader->ArrayLength(reader, &num_items) != 0) {
-        fprintf(stderr, "error determing list_int length\n");
+        // fprintf(stderr, "error determing list_int length\n");
         status = -1;
         break;
       }
@@ -680,20 +680,20 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
       tvm_crt_error_t err = TVMPlatformMemoryAllocate(sizeof(TVMGraphExecutorNodeEntry) * num_items,
                                                       dev, (void**)&executor->outputs);
       if (err != kTvmErrorNoError) {
-        fprintf(stderr, "memory allocate error: %08x", err);
+        // fprintf(stderr, "memory allocate error: %08x", err);
         status = -1;
         break;
       }
       while (reader->NextArrayItem(reader)) {
         if (executor->outputs_count == num_items) {
-          fprintf(stderr, "array too big\n");
+          // fprintf(stderr, "array too big\n");
           status = -1;
           return status;
         }
         TVMGraphExecutorNodeEntry* entry = executor->outputs + executor->outputs_count;
         status = NodeEntry_Load(entry, reader);
         if (status != 0) {
-          fprintf(stderr, "Fail to load an element in `heads` field in graph executor node.\n");
+          // fprintf(stderr, "Fail to load an element in `heads` field in graph executor node.\n");
           break;
         }
         executor->outputs_count++;
@@ -702,14 +702,14 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
     } else if (!strcmp(key, "attrs")) {
       status = TVMGraphExecutorGraphAttr_Load(&(executor->attrs), reader);
       if (status != 0) {
-        fprintf(stderr, "Fail to load an element in `heads` field in graph executor node.\n");
+        // fprintf(stderr, "Fail to load an element in `heads` field in graph executor node.\n");
         break;
       }
       bitmask |= 16;
     } else if (!strcmp(key, "metadata")) {
       break;
     } else {
-      fprintf(stderr, "key %s is not supported\n", key);
+      // fprintf(stderr, "key %s is not supported\n", key);
       status = -1;
     }
     if (status != 0) {
@@ -717,7 +717,7 @@ int TVMGraphExecutor_Load(TVMGraphExecutor* executor, JSONReader* reader) {
     }
   }
   if (!(bitmask == (1 | 2 | 4 | 8 | 16))) {
-    fprintf(stderr, "invalid format\n");
+    // fprintf(stderr, "invalid format\n");
     status = -1;
   }
   return status;
@@ -765,7 +765,7 @@ int TVMGraphExecutor_GetInputIndex(TVMGraphExecutor* executor, const char* name)
 void TVMGraphExecutor_SetInput(TVMGraphExecutor* executor, const char* name, DLTensor* data_in) {
   uint32_t index = TVMGraphExecutor_GetInputIndex(executor, name);
   if (index >= executor->input_nodes_count) {
-    fprintf(stderr, "given index is greater than num of input nodes.\n");
+    // fprintf(stderr, "given index is greater than num of input nodes.\n");
   }
   uint32_t eid = TVMGraphExecutor_GetEntryId(executor, executor->input_nodes[index], 0);
   executor->data_entry[eid].dl_tensor.data = data_in->data;
@@ -786,7 +786,7 @@ int TVMGraphExecutor_LoadParams(TVMGraphExecutor* executor, const char* param_bl
   memcpy(&header, bptr, sizeof(header));
   bptr += sizeof(header);
   if (header != kTVMNDArrayListMagic) {
-    fprintf(stderr, "Invalid parameters file format");
+    // fprintf(stderr, "Invalid parameters file format");
     status = -1;
   }
   memcpy(&reserved, bptr, sizeof(reserved));
@@ -798,7 +798,7 @@ int TVMGraphExecutor_LoadParams(TVMGraphExecutor* executor, const char* param_bl
   tvm_crt_error_t err = TVMPlatformMemoryAllocate(
       TVM_CRT_MAX_STRLEN_PARAM_NAME * executor->nodes_count, dev, (void**)&names);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     status = -1;
     return status;
   }
@@ -812,7 +812,7 @@ int TVMGraphExecutor_LoadParams(TVMGraphExecutor* executor, const char* param_bl
     memcpy(&name_length, bptr, sizeof(name_length));
     bptr += sizeof(name_length);
     if (name_length >= TVM_CRT_MAX_STRLEN_PARAM_NAME) {
-      fprintf(stderr, "Error: function name longer than expected.\n");
+      // fprintf(stderr, "Error: function name longer than expected.\n");
       status = -1;
     }
     memcpy(names + TVM_CRT_MAX_STRLEN_PARAM_NAME * idx, bptr, name_length);
@@ -825,7 +825,7 @@ int TVMGraphExecutor_LoadParams(TVMGraphExecutor* executor, const char* param_bl
   bptr += sizeof(sz);
   uint32_t size = sz;
   if (size != names_count) {
-    fprintf(stderr, "Invalid parameters file format\n");
+    // fprintf(stderr, "Invalid parameters file format\n");
     status = -1;
   }
 
@@ -836,8 +836,8 @@ int TVMGraphExecutor_LoadParams(TVMGraphExecutor* executor, const char* param_bl
              names + TVM_CRT_MAX_STRLEN_PARAM_NAME * idx);
     uint32_t eid = TVMGraphExecutor_GetEntryId(executor, executor->input_nodes[in_idx], 0);
     if (!(eid < executor->data_entry_count)) {
-      fprintf(stderr, "`entry_id`=%d is greater than expected(%d).\n", eid,
-              executor->data_entry_count);
+      // fprintf(stderr, "`entry_id`=%d is greater than expected(%d).\n", eid,
+      //         executor->data_entry_count);
       status = -1;
     }
 
@@ -937,7 +937,7 @@ int TVMGraphExecutor_SetupStorage(TVMGraphExecutor* executor) {
   tvm_crt_error_t err = TVMPlatformMemoryAllocate(sizeof(DLDataType) * attrs->dltype_count,
                                                   alloc_dev, (void**)&vtype);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     return -1;
   }
   for (idx = 0; idx < attrs->dltype_count; idx++) {
@@ -949,7 +949,7 @@ int TVMGraphExecutor_SetupStorage(TVMGraphExecutor* executor) {
   err = TVMPlatformMemoryAllocate(sizeof(TVMGraphExecutorPoolEntry) * executor->nodes_count,
                                   alloc_dev, (void**)&pool_entry);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     return -1;
   }
   memset(pool_entry, 0, sizeof(TVMGraphExecutorPoolEntry) * executor->nodes_count);
@@ -977,7 +977,7 @@ int TVMGraphExecutor_SetupStorage(TVMGraphExecutor* executor) {
   err = TVMPlatformMemoryAllocate(sizeof(TVMGraphExecutorStorageEntry) * pool_entry_count,
                                   alloc_dev, (void**)&executor->storage_pool);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     return -1;
   }
   for (idx = 0; idx < pool_entry_count; idx++) {
@@ -1021,7 +1021,7 @@ int TVMGraphExecutor_SetupStorage(TVMGraphExecutor* executor) {
   err = TVMPlatformMemoryAllocate(sizeof(TVMNDArray) * executor->data_entry_count, alloc_dev,
                                   (void**)&executor->data_entry);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     return -1;
   }
   for (idx = 0; idx < executor->data_entry_count; ++idx) {
@@ -1038,13 +1038,13 @@ int TVMGraphExecutor_SetupStorage(TVMGraphExecutor* executor) {
   // Release memory
   err = TVMPlatformMemoryFree(vtype, alloc_dev);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory free error: %08x", err);
+    // fprintf(stderr, "memory free error: %08x", err);
     return err;
   }
 
   err = TVMPlatformMemoryFree(pool_entry, alloc_dev);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory free error: %08x", err);
+    // fprintf(stderr, "memory free error: %08x", err);
     return -1;
   }
 
@@ -1059,7 +1059,7 @@ int TVMGraphExecutor_SetupOpExecs(TVMGraphExecutor* executor) {
   tvm_crt_error_t err = TVMPlatformMemoryAllocate(sizeof(TVMPackedFunc) * executor->op_execs_count,
                                                   dev, (void**)&executor->op_execs);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     status = -1;
     return status;
   }
@@ -1080,13 +1080,13 @@ int TVMGraphExecutor_SetupOpExecs(TVMGraphExecutor* executor) {
         args_count++;
       }
       if (strcmp(inode->op_type, "tvm_op")) {
-        fprintf(stderr, "Can only take tvm_op as op, but \"%s\" is found.\n", inode->op_type);
+        // fprintf(stderr, "Can only take tvm_op as op, but \"%s\" is found.\n", inode->op_type);
         status = -1;
         break;
       }
       if (args_count >= TVM_CRT_MAX_ARGS) {
-        fprintf(stderr, "too many arguments: expected less than %d args, but got %d.\n",
-                TVM_CRT_MAX_ARGS, args_count);
+        // fprintf(stderr, "too many arguments: expected less than %d args, but got %d.\n",
+        //         TVM_CRT_MAX_ARGS, args_count);
         status = -1;
         break;
       }
@@ -1142,7 +1142,7 @@ int32_t TVMGraphExecutor_CreateTVMOp(TVMGraphExecutor* executor, const TVMOpPara
     }
   }
   if (!strcmp(param->func_name, "__nop") || !strcmp(param->func_name, "__copy")) {
-    fprintf(stderr, "%s function is not yet supported.", param->func_name);
+    // fprintf(stderr, "%s function is not yet supported.", param->func_name);
     status = -1;
   }
 
@@ -1192,7 +1192,7 @@ int TVMGraphExecutor_Create(const char* sym_json, TVMModuleHandle module_handle,
   DLDevice dev = {kDLCPU, 0};
   tvm_crt_error_t err = TVMPlatformMemoryAllocate(sizeof(TVMGraphExecutor), dev, (void**)executor);
   if (err != kTvmErrorNoError) {
-    fprintf(stderr, "memory allocate error: %08x", err);
+    // fprintf(stderr, "memory allocate error: %08x", err);
     return -1;
   }
 
diff --git a/src/runtime/crt/graph_executor/load_json.c b/src/runtime/crt/graph_executor/load_json.c
index f1c1f67..242b87e 100644
--- a/src/runtime/crt/graph_executor/load_json.c
+++ b/src/runtime/crt/graph_executor/load_json.c
@@ -40,17 +40,17 @@ typedef struct JSONNodeEntry {
 void JSONNodeEntryLoad(JSONNodeEntry* entry, JSONReader* reader) {
   reader->BeginArray(reader);
   if (reader->NextArrayItem(reader)) {
-    fprintf(stderr, "invalid json format\n");
+    // fprintf(stderr, "invalid json format\n");
   }
   reader->ReadUnsignedInteger(reader, &(entry->node_id));
   if (reader->NextArrayItem(reader)) {
-    fprintf(stderr, "invalid json format\n");
+    // fprintf(stderr, "invalid json format\n");
   }
   reader->ReadUnsignedInteger(reader, &(entry->index));
   if (reader->NextArrayItem(reader)) {
     reader->ReadUnsignedInteger(reader, &(entry->version));
     if (!reader->NextArrayItem(reader)) {
-      fprintf(stderr, "invalid json format\n");
+      // fprintf(stderr, "invalid json format\n");
     }
   } else {
     entry->version = 0;
@@ -60,27 +60,27 @@ void JSONNodeEntryLoad(JSONNodeEntry* entry, JSONReader* reader) {
 // implementation of Seq class
 
 void SeqPush(Seq* seq, uint32_t src) {
-  if (seq->size >= seq->allocated) {
-    printf("seq too large.\n");
-  }
+  // if (seq->size >= seq->allocated) {
+  //   printf("seq too large.\n");
+  // }
   seq->data[seq->size] = src;
   seq->size += 1;
 }
 
 uint32_t* SeqBack(Seq* seq) {
-  if (seq->size >= seq->allocated) {
-    printf("seq too large.\n");
-  }
+  // if (seq->size >= seq->allocated) {
+  //   printf("seq too large.\n");
+  // }
   return seq->data + (seq->size - 1);
 }
 
 void SeqPop(Seq* seq) {
-  if (seq->size >= seq->allocated) {
-    printf("seq size is too large.\n");
-  }
-  if (seq->size == 0) {
-    printf("seq size is too small.\n");
-  }
+  // if (seq->size >= seq->allocated) {
+  //   printf("seq size is too large.\n");
+  // }
+  // if (seq->size == 0) {
+  //   printf("seq size is too small.\n");
+  // }
   seq->size -= 1;
 }
 
@@ -200,7 +200,7 @@ int JSONReader_ReadString(JSONReader* reader, char* out_str, size_t out_str_size
           out_str[output_counter++] = '\"';
           break;
         default:
-          fprintf(stderr, "unknown string escape %c\n", sch);
+          // fprintf(stderr, "unknown string escape %c\n", sch);
           break;
       }
     } else {
@@ -212,12 +212,12 @@ int JSONReader_ReadString(JSONReader* reader, char* out_str, size_t out_str_size
       }
     }
     if (output_counter == out_str_size - 1) {
-      fprintf(stderr, "Error: string size greater than buffer size (%zu).\n", out_str_size);
+      // fprintf(stderr, "Error: string size greater than buffer size (%zu).\n", out_str_size);
       break;
     }
     if (ch == EOF || ch == '\r' || ch == '\n') {
-      fprintf(stderr, "Error at line %zu, Expect \'\"\' but reach end of line\n",
-              reader->line_count_n_);
+      // fprintf(stderr, "Error at line %zu, Expect \'\"\' but reach end of line\n",
+      //         reader->line_count_n_);
       break;
     }
   }
@@ -264,7 +264,7 @@ int JSONReader_ReadInteger(JSONReader* reader, int64_t* out_value) {
 void JSONReader_BeginObject(JSONReader* reader) {
   int ch = reader->NextNonSpace(reader);
   if (!(ch == '{')) {
-    fprintf(stderr, "Error at line %zu, Expect \'{\' but got \'%c\'\n", reader->line_count_n_, ch);
+    // fprintf(stderr, "Error at line %zu, Expect \'{\' but got \'%c\'\n", reader->line_count_n_, ch);
   }
   Seq* scope_counter_ = reader->scope_counter_;
   scope_counter_->push_back(scope_counter_, 0);
@@ -289,8 +289,8 @@ uint8_t JSONReader_NextObjectItem(JSONReader* reader, char* out_key, size_t out_
       next = 0;
     } else {
       if (ch != ',') {
-        fprintf(stderr, "Error at line %zu, JSON object expect \'}\' or \',\' but got \'%c\'\n",
-                reader->line_count_n_, ch);
+        // fprintf(stderr, "Error at line %zu, JSON object expect \'}\' or \',\' but got \'%c\'\n",
+        //         reader->line_count_n_, ch);
       }
     }
   } else {
@@ -307,13 +307,13 @@ uint8_t JSONReader_NextObjectItem(JSONReader* reader, char* out_key, size_t out_
     scope_counter_->back(scope_counter_)[0] += 1;
     int err = reader->ReadString(reader, out_key, out_key_size);
     if (err != 0) {
-      fprintf(stderr, "error reading key");
+      // fprintf(stderr, "error reading key");
       return 0;
     }
     int ch = reader->NextNonSpace(reader);
     if (ch != ':') {
-      fprintf(stderr, "Error at line %zu, Expect \':\' but get \'%c\'\n", reader->line_count_n_,
-              ch);
+      // fprintf(stderr, "Error at line %zu, Expect \':\' but get \'%c\'\n", reader->line_count_n_,
+      //         ch);
     }
     return 1;
   }
@@ -333,7 +333,7 @@ uint8_t JSONReader_NextObjectItem(JSONReader* reader, char* out_key, size_t out_
 void JSONReader_BeginArray(JSONReader* reader) {
   int ch = reader->NextNonSpace(reader);
   if (ch != '[') {
-    fprintf(stderr, "Error at line %zu, Expect \'[\' but get \'%c\'\n", reader->line_count_n_, ch);
+    // fprintf(stderr, "Error at line %zu, Expect \'[\' but get \'%c\'\n", reader->line_count_n_, ch);
   }
   Seq* scope_counter_ = reader->scope_counter_;
   scope_counter_->push_back(scope_counter_, 0);
@@ -356,8 +356,8 @@ uint8_t JSONReader_NextArrayItem(JSONReader* reader) {
       next = 0;
     } else {
       if (ch != ',') {
-        fprintf(stderr, "Error at line %zu, JSON object expect \']\' or \',\' but got \'%c\'\n",
-                reader->line_count_n_, ch);
+        // fprintf(stderr, "Error at line %zu, JSON object expect \']\' or \',\' but got \'%c\'\n",
+        //         reader->line_count_n_, ch);
       }
     }
   } else {
